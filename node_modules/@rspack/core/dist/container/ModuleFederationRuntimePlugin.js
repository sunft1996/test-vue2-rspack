"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleFederationRuntimePlugin = void 0;
const base_1 = require("../builtin-plugin/base");
const EntryPlugin_1 = require("../builtin-plugin/EntryPlugin");
const ModuleFederationRuntimePlugin2 = (0, base_1.create)(base_1.BuiltinPluginName.ModuleFederationRuntimePlugin, () => undefined);
const compilerToPlugins = new WeakMap();
class ModuleFederationRuntimePlugin {
    apply(compiler) {
        // TODO: a hack to make sure this runtime is added after ContainerReferencePlugin
        // remove afterPlugin once we make rust side runtime_requirements_in_tree "tapable"
        compiler.hooks.afterPlugins.tap({ name: ModuleFederationRuntimePlugin.name, stage: 10 }, () => {
            const plugins = compilerToPlugins.get(compiler);
            if (plugins) {
                // TODO: move to rust side so don't depend on dataUrl?
                const entry = [...plugins]
                    .map(p => `import ${JSON.stringify(p)};`)
                    .join("\n");
                new EntryPlugin_1.EntryPlugin(compiler.context, `data:text/javascript,${entry}`, {
                    name: undefined
                }).apply(compiler);
            }
            new ModuleFederationRuntimePlugin2().apply(compiler);
        });
    }
    static addPlugin(compiler, plugin) {
        let plugins = compilerToPlugins.get(compiler);
        if (!plugins) {
            compilerToPlugins.set(compiler, (plugins = new Set()));
        }
        plugins.add(plugin);
    }
}
exports.ModuleFederationRuntimePlugin = ModuleFederationRuntimePlugin;
