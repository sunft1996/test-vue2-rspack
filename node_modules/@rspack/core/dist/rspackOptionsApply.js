"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RspackOptionsApply = exports.optionsApply_compat = void 0;
const graceful_fs_1 = __importDefault(require("graceful-fs"));
const ResolveSwcPlugin_1 = require("./web/ResolveSwcPlugin");
const DefaultStatsFactoryPlugin_1 = require("./stats/DefaultStatsFactoryPlugin");
const DefaultStatsPrinterPlugin_1 = require("./stats/DefaultStatsPrinterPlugin");
const cleverMerge_1 = require("./util/cleverMerge");
const assert_1 = __importDefault(require("assert"));
const ignoreWarningsPlugin_1 = __importDefault(require("./lib/ignoreWarningsPlugin"));
const EntryOptionPlugin_1 = __importDefault(require("./lib/EntryOptionPlugin"));
const builtin_plugin_1 = require("./builtin-plugin");
const ModuleFederationRuntimePlugin_1 = require("./container/ModuleFederationRuntimePlugin");
function optionsApply_compat(compiler, options) {
    var _a;
    if (compiler.parentCompilation === undefined) {
        if (options.externals) {
            (0, assert_1.default)(options.externalsType, "options.externalsType should have value after `applyRspackOptionsDefaults`");
            new builtin_plugin_1.ExternalsPlugin(options.externalsType, options.externals).apply(compiler);
        }
        if (options.externalsPresets.node) {
            new builtin_plugin_1.NodeTargetPlugin().apply(compiler);
        }
        if (options.externalsPresets.electronMain) {
            new builtin_plugin_1.ElectronTargetPlugin("main").apply(compiler);
        }
        if (options.externalsPresets.electronPreload) {
            new builtin_plugin_1.ElectronTargetPlugin("preload").apply(compiler);
        }
        if (options.externalsPresets.electronRenderer) {
            new builtin_plugin_1.ElectronTargetPlugin("renderer").apply(compiler);
        }
        if (options.externalsPresets.electron &&
            !options.externalsPresets.electronMain &&
            !options.externalsPresets.electronPreload &&
            !options.externalsPresets.electronRenderer) {
            new builtin_plugin_1.ElectronTargetPlugin().apply(compiler);
        }
        if (options.externalsPresets.web ||
            options.externalsPresets.webAsync ||
            (options.externalsPresets.node && options.experiments.css)) {
            new builtin_plugin_1.HttpExternalsRspackPlugin(!!options.experiments.css, !!options.externalsPresets.webAsync).apply(compiler);
        }
        if (typeof options.output.chunkFormat === "string") {
            switch (options.output.chunkFormat) {
                case "array-push": {
                    new builtin_plugin_1.ArrayPushCallbackChunkFormatPlugin().apply(compiler);
                    break;
                }
                case "commonjs": {
                    new builtin_plugin_1.CommonJsChunkFormatPlugin().apply(compiler);
                    break;
                }
                case "module": {
                    new builtin_plugin_1.ModuleChunkFormatPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error("Unsupported chunk format '" + options.output.chunkFormat + "'.");
            }
        }
        if (options.output.enabledChunkLoadingTypes &&
            options.output.enabledChunkLoadingTypes.length > 0) {
            for (const type of options.output.enabledChunkLoadingTypes) {
                new builtin_plugin_1.EnableChunkLoadingPlugin(type).apply(compiler);
            }
        }
        if (options.output.enabledWasmLoadingTypes &&
            options.output.enabledWasmLoadingTypes.length > 0) {
            for (const type of options.output.enabledWasmLoadingTypes) {
                new builtin_plugin_1.EnableWasmLoadingPlugin(type).apply(compiler);
            }
        }
        if (options.output.enabledLibraryTypes &&
            options.output.enabledLibraryTypes.length > 0) {
            for (const type of options.output.enabledLibraryTypes) {
                new builtin_plugin_1.EnableLibraryPlugin(type).apply(compiler);
            }
        }
        // TODO: change to new EntryOptionPlugin().apply(compiler);
        EntryOptionPlugin_1.default.applyEntryOption(compiler, compiler.context, options.entry);
        if ((_a = options.devServer) === null || _a === void 0 ? void 0 : _a.hot) {
            new compiler.webpack.HotModuleReplacementPlugin().apply(compiler);
        }
    }
}
exports.optionsApply_compat = optionsApply_compat;
class RspackOptionsApply {
    constructor() { }
    process(options, compiler) {
        var _a;
        (0, assert_1.default)(options.output.path, "options.output.path should have value after `applyRspackOptionsDefaults`");
        compiler.outputPath = options.output.path;
        compiler.name = options.name;
        compiler.outputFileSystem = graceful_fs_1.default;
        const runtimeChunk = options.optimization
            .runtimeChunk;
        if (runtimeChunk) {
            Object.entries(options.entry).forEach(([entryName, value]) => {
                if (value.runtime === undefined) {
                    value.runtime = runtimeChunk.name({ name: entryName });
                }
            });
        }
        // new EntryOptionPlugin().apply(compiler);
        (0, assert_1.default)(options.context, "options.context should have value after `applyRspackOptionsDefaults`");
        compiler.hooks.entryOption.call(options.context, options.entry);
        new ModuleFederationRuntimePlugin_1.ModuleFederationRuntimePlugin().apply(compiler);
        const { minimize, minimizer } = options.optimization;
        if (minimize && minimizer) {
            for (const item of minimizer) {
                if (typeof item === "function") {
                    item.call(compiler, compiler);
                }
                else if (item !== "...") {
                    item.apply(compiler);
                }
            }
        }
        if (options.optimization.mergeDuplicateChunks) {
            new builtin_plugin_1.MergeDuplicateChunksPlugin().apply(compiler);
        }
        if (options.builtins.devFriendlySplitChunks) {
            options.optimization.splitChunks = undefined;
        }
        if (options.optimization.splitChunks &&
            options.experiments.newSplitChunks === false) {
            new builtin_plugin_1.OldSplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
        }
        else if (options.optimization.splitChunks) {
            new builtin_plugin_1.SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
        }
        if (options.optimization.nodeEnv) {
            new builtin_plugin_1.DefinePlugin({
                "process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
            }).apply(compiler);
        }
        if ((_a = options.devServer) === null || _a === void 0 ? void 0 : _a.hot) {
            options.output.strictModuleErrorHandling = true;
        }
        new ResolveSwcPlugin_1.ResolveSwcPlugin().apply(compiler);
        new DefaultStatsFactoryPlugin_1.DefaultStatsFactoryPlugin().apply(compiler);
        new DefaultStatsPrinterPlugin_1.DefaultStatsPrinterPlugin().apply(compiler);
        if (options.ignoreWarnings && options.ignoreWarnings.length > 0) {
            new ignoreWarningsPlugin_1.default(options.ignoreWarnings).apply(compiler);
        }
        compiler.hooks.afterPlugins.call(compiler);
        if (!compiler.inputFileSystem) {
            throw new Error("No input filesystem provided");
        }
        compiler.resolverFactory.hooks.resolveOptions
            .for("normal")
            .tap("RspackOptionsApply", resolveOptions => {
            resolveOptions = (0, cleverMerge_1.cleverMerge)(options.resolve, resolveOptions);
            resolveOptions.fileSystem = compiler.inputFileSystem;
            return resolveOptions;
        });
        compiler.resolverFactory.hooks.resolveOptions
            .for("context")
            .tap("RspackOptionsApply", resolveOptions => {
            resolveOptions = (0, cleverMerge_1.cleverMerge)(options.resolve, resolveOptions);
            resolveOptions.fileSystem = compiler.inputFileSystem;
            resolveOptions.resolveToContext = true;
            return resolveOptions;
        });
        compiler.hooks.afterResolvers.call(compiler);
    }
}
exports.RspackOptionsApply = RspackOptionsApply;
